#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Generated Tue Aug  6 14:52:49 2013 by generateDS.py version 2.10a.
#
# Copyright (C) 2011,2012,2013 American Registry for Internet Numbers
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
# IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#
# Generated Tue Aug  6 14:52:53 2013 by generateDS.py version 2.10a.
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ticketedRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, message=None, attachment=None, ticket=None, net=None, netBlock=None, pocLinkRef=None):
        self.message = message
        self.attachment = attachment
        self.ticket = ticket
        self.attachment = attachment
        self.net = net
        self.netBlock = netBlock
        self.pocLinkRef = pocLinkRef
    def factory(*args_, **kwargs_):
        if ticketedRequest.subclass:
            return ticketedRequest.subclass(*args_, **kwargs_)
        else:
            return ticketedRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def get_ticket(self): return self.ticket
    def set_ticket(self, ticket): self.ticket = ticket
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def get_net(self): return self.net
    def set_net(self, net): self.net = net
    def get_netBlock(self): return self.netBlock
    def set_netBlock(self, netBlock): self.netBlock = netBlock
    def get_pocLinkRef(self): return self.pocLinkRef
    def set_pocLinkRef(self, pocLinkRef): self.pocLinkRef = pocLinkRef
    def hasContent_(self):
        if (
            self.message is not None or
            self.attachment is not None or
            self.ticket is not None or
            self.attachment is not None or
            self.net is not None or
            self.netBlock is not None or
            self.pocLinkRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='ticketedRequest', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ticketedRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='ticketedRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='ticketedRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.message is not None:
            self.message.export(outfile, level, namespace_, name_='message', pretty_print=pretty_print)
        if self.attachment is not None:
            self.attachment.export(outfile, level, namespace_, name_='attachment', pretty_print=pretty_print)
        if self.ticket is not None:
            self.ticket.export(outfile, level, namespace_, name_='ticket', pretty_print=pretty_print)
        if self.attachment is not None:
            self.attachment.export(outfile, level, namespace_, name_='attachment', pretty_print=pretty_print)
        if self.net is not None:
            self.net.export(outfile, level, namespace_, name_='net', pretty_print=pretty_print)
        if self.netBlock is not None:
            self.netBlock.export(outfile, level, namespace_, name_='netBlock', pretty_print=pretty_print)
        if self.pocLinkRef is not None:
            self.pocLinkRef.export(outfile, level, namespace_, name_='pocLinkRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ticketedRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=model_.message(\n')
            self.message.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attachment is not None:
            showIndent(outfile, level)
            outfile.write('attachment=model_.attachmentType(\n')
            self.attachment.exportLiteral(outfile, level, name_='attachment')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ticket is not None:
            showIndent(outfile, level)
            outfile.write('ticket=model_.ticket(\n')
            self.ticket.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attachment is not None:
            showIndent(outfile, level)
            outfile.write('attachment=model_.attachmentType2(\n')
            self.attachment.exportLiteral(outfile, level, name_='attachment')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.net is not None:
            showIndent(outfile, level)
            outfile.write('net=model_.net(\n')
            self.net.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.netBlock is not None:
            showIndent(outfile, level)
            outfile.write('netBlock=model_.netBlock(\n')
            self.netBlock.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pocLinkRef is not None:
            showIndent(outfile, level)
            outfile.write('pocLinkRef=model_.pocLinkRef(\n')
            self.pocLinkRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'message':
            obj_ = message.factory()
            obj_.build(child_)
            self.set_message(obj_)
        elif nodeName_ == 'attachment':
            obj_ = attachmentType.factory()
            obj_.build(child_)
            self.set_attachment(obj_)
        elif nodeName_ == 'ticket':
            obj_ = ticket.factory()
            obj_.build(child_)
            self.set_ticket(obj_)
        elif nodeName_ == 'attachment':
            obj_ = attachmentType2.factory()
            obj_.build(child_)
            self.set_attachment(obj_)
        elif nodeName_ == 'net':
            obj_ = net.factory()
            obj_.build(child_)
            self.set_net(obj_)
        elif nodeName_ == 'netBlock':
            obj_ = netBlock.factory()
            obj_.build(child_)
            self.set_netBlock(obj_)
        elif nodeName_ == 'pocLinkRef':
            obj_ = pocLinkRef.factory()
            obj_.build(child_)
            self.set_pocLinkRef(obj_)
# end class ticketedRequest


class message(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachments=None, attachmentReferences=None, category=None, subject=None, text=None, messageId=None, createdDate=None, anytypeobjs_=None):
        self.attachments = attachments
        self.attachmentReferences = attachmentReferences
        self.category = category
        self.subject = subject
        self.text = text
        self.messageId = messageId
        self.createdDate = createdDate
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if message.subclass:
            return message.subclass(*args_, **kwargs_)
        else:
            return message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachments(self): return self.attachments
    def set_attachments(self, attachments): self.attachments = attachments
    def get_attachmentReferences(self): return self.attachmentReferences
    def set_attachmentReferences(self, attachmentReferences): self.attachmentReferences = attachmentReferences
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_messageId(self): return self.messageId
    def set_messageId(self, messageId): self.messageId = messageId
    def get_createdDate(self): return self.createdDate
    def set_createdDate(self, createdDate): self.createdDate = createdDate
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachments is not None or
            self.attachmentReferences is not None or
            self.category is not None or
            self.subject is not None or
            self.text is not None or
            self.messageId is not None or
            self.createdDate is not None or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='message', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='message')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='message'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='message', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attachments is not None:
            self.attachments.export(outfile, level, namespace_, name_='attachments', pretty_print=pretty_print)
        if self.attachmentReferences is not None:
            self.attachmentReferences.export(outfile, level, namespace_, name_='attachmentReferences', pretty_print=pretty_print)
        if self.category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scategory>%s</%scategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.category).encode(ExternalEncoding), input_name='category'), namespace_, eol_))
        if self.subject is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubject>%s</%ssubject>%s' % (namespace_, self.gds_format_string(quote_xml(self.subject).encode(ExternalEncoding), input_name='subject'), namespace_, eol_))
        if self.text is not None:
            self.text.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
        if self.messageId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smessageId>%s</%smessageId>%s' % (namespace_, self.gds_format_integer(self.messageId, input_name='messageId'), namespace_, eol_))
        if self.createdDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screatedDate>%s</%screatedDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.createdDate).encode(ExternalEncoding), input_name='createdDate'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='message'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attachments is not None:
            showIndent(outfile, level)
            outfile.write('attachments=model_.attachments(\n')
            self.attachments.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attachmentReferences is not None:
            showIndent(outfile, level)
            outfile.write('attachmentReferences=model_.attachmentReferencesType(\n')
            self.attachmentReferences.exportLiteral(outfile, level, name_='attachmentReferences')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.category is not None:
            showIndent(outfile, level)
            outfile.write('category=%s,\n' % quote_python(self.category).encode(ExternalEncoding))
        if self.subject is not None:
            showIndent(outfile, level)
            outfile.write('subject=%s,\n' % quote_python(self.subject).encode(ExternalEncoding))
        if self.text is not None:
            showIndent(outfile, level)
            outfile.write('text=model_.text(\n')
            self.text.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.messageId is not None:
            showIndent(outfile, level)
            outfile.write('messageId=%d,\n' % self.messageId)
        if self.createdDate is not None:
            showIndent(outfile, level)
            outfile.write('createdDate=%s,\n' % quote_python(self.createdDate).encode(ExternalEncoding))
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachments':
            obj_ = attachments.factory()
            obj_.build(child_)
            self.set_attachments(obj_)
        elif nodeName_ == 'attachmentReferences':
            obj_ = attachmentReferencesType.factory()
            obj_.build(child_)
            self.set_attachmentReferences(obj_)
        elif nodeName_ == 'category':
            category_ = child_.text
            category_ = self.gds_validate_string(category_, node, 'category')
            self.category = category_
        elif nodeName_ == 'subject':
            subject_ = child_.text
            subject_ = self.gds_validate_string(subject_, node, 'subject')
            self.subject = subject_
        elif nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.set_text(obj_)
        elif nodeName_ == 'messageId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'messageId')
            self.messageId = ival_
        elif nodeName_ == 'createdDate':
            createdDate_ = child_.text
            createdDate_ = self.gds_validate_string(createdDate_, node, 'createdDate')
            self.createdDate = createdDate_
        else:
            obj_ = self.gds_build_any(child_, 'message')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class message


class ticket(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, closedDate=None, createdDate=None, flagged=None, messages=None, messageReferences=None, resolvedDate=None, ticketNo=None, updatedDate=None, webTicketResolution=None, webTicketStatus=None, webTicketType=None, anytypeobjs_=None):
        if closedDate is None:
            self.closedDate = []
        else:
            self.closedDate = closedDate
        if createdDate is None:
            self.createdDate = []
        else:
            self.createdDate = createdDate
        if flagged is None:
            self.flagged = []
        else:
            self.flagged = flagged
        self.messages = messages
        self.messageReferences = messageReferences
        self.resolvedDate = resolvedDate
        self.ticketNo = ticketNo
        self.updatedDate = updatedDate
        self.webTicketResolution = webTicketResolution
        self.webTicketStatus = webTicketStatus
        self.webTicketType = webTicketType
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ticket.subclass:
            return ticket.subclass(*args_, **kwargs_)
        else:
            return ticket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_closedDate(self): return self.closedDate
    def set_closedDate(self, closedDate): self.closedDate = closedDate
    def add_closedDate(self, value): self.closedDate.append(value)
    def insert_closedDate(self, index, value): self.closedDate[index] = value
    def get_createdDate(self): return self.createdDate
    def set_createdDate(self, createdDate): self.createdDate = createdDate
    def add_createdDate(self, value): self.createdDate.append(value)
    def insert_createdDate(self, index, value): self.createdDate[index] = value
    def get_flagged(self): return self.flagged
    def set_flagged(self, flagged): self.flagged = flagged
    def add_flagged(self, value): self.flagged.append(value)
    def insert_flagged(self, index, value): self.flagged[index] = value
    def get_messages(self): return self.messages
    def set_messages(self, messages): self.messages = messages
    def get_messageReferences(self): return self.messageReferences
    def set_messageReferences(self, messageReferences): self.messageReferences = messageReferences
    def get_resolvedDate(self): return self.resolvedDate
    def set_resolvedDate(self, resolvedDate): self.resolvedDate = resolvedDate
    def get_ticketNo(self): return self.ticketNo
    def set_ticketNo(self, ticketNo): self.ticketNo = ticketNo
    def get_updatedDate(self): return self.updatedDate
    def set_updatedDate(self, updatedDate): self.updatedDate = updatedDate
    def get_webTicketResolution(self): return self.webTicketResolution
    def set_webTicketResolution(self, webTicketResolution): self.webTicketResolution = webTicketResolution
    def get_webTicketStatus(self): return self.webTicketStatus
    def set_webTicketStatus(self, webTicketStatus): self.webTicketStatus = webTicketStatus
    def get_webTicketType(self): return self.webTicketType
    def set_webTicketType(self, webTicketType): self.webTicketType = webTicketType
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.closedDate or
            self.createdDate or
            self.flagged or
            self.messages is not None or
            self.messageReferences is not None or
            self.resolvedDate is not None or
            self.ticketNo is not None or
            self.updatedDate is not None or
            self.webTicketResolution is not None or
            self.webTicketStatus is not None or
            self.webTicketType is not None or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='ticket', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ticket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='ticket'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='ticket', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for closedDate_ in self.closedDate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclosedDate>%s</%sclosedDate>%s' % (namespace_, self.gds_format_string(quote_xml(closedDate_).encode(ExternalEncoding), input_name='closedDate'), namespace_, eol_))
        for createdDate_ in self.createdDate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screatedDate>%s</%screatedDate>%s' % (namespace_, self.gds_format_string(quote_xml(createdDate_).encode(ExternalEncoding), input_name='createdDate'), namespace_, eol_))
        for flagged_ in self.flagged:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflagged>%s</%sflagged>%s' % (namespace_, self.gds_format_string(quote_xml(flagged_).encode(ExternalEncoding), input_name='flagged'), namespace_, eol_))
        if self.messages is not None:
            self.messages.export(outfile, level, namespace_, name_='messages', pretty_print=pretty_print)
        if self.messageReferences is not None:
            self.messageReferences.export(outfile, level, namespace_, name_='messageReferences', pretty_print=pretty_print)
        if self.resolvedDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresolvedDate>%s</%sresolvedDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.resolvedDate).encode(ExternalEncoding), input_name='resolvedDate'), namespace_, eol_))
        if self.ticketNo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sticketNo>%s</%sticketNo>%s' % (namespace_, self.gds_format_string(quote_xml(self.ticketNo).encode(ExternalEncoding), input_name='ticketNo'), namespace_, eol_))
        if self.updatedDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supdatedDate>%s</%supdatedDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.updatedDate).encode(ExternalEncoding), input_name='updatedDate'), namespace_, eol_))
        if self.webTicketResolution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swebTicketResolution>%s</%swebTicketResolution>%s' % (namespace_, self.gds_format_string(quote_xml(self.webTicketResolution).encode(ExternalEncoding), input_name='webTicketResolution'), namespace_, eol_))
        if self.webTicketStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swebTicketStatus>%s</%swebTicketStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.webTicketStatus).encode(ExternalEncoding), input_name='webTicketStatus'), namespace_, eol_))
        if self.webTicketType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swebTicketType>%s</%swebTicketType>%s' % (namespace_, self.gds_format_string(quote_xml(self.webTicketType).encode(ExternalEncoding), input_name='webTicketType'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ticket'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('closedDate=[\n')
        level += 1
        for closedDate_ in self.closedDate:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(closedDate_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('createdDate=[\n')
        level += 1
        for createdDate_ in self.createdDate:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(createdDate_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('flagged=[\n')
        level += 1
        for flagged_ in self.flagged:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(flagged_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.messages is not None:
            showIndent(outfile, level)
            outfile.write('messages=model_.messages(\n')
            self.messages.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.messageReferences is not None:
            showIndent(outfile, level)
            outfile.write('messageReferences=model_.messageReferences(\n')
            self.messageReferences.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resolvedDate is not None:
            showIndent(outfile, level)
            outfile.write('resolvedDate=%s,\n' % quote_python(self.resolvedDate).encode(ExternalEncoding))
        if self.ticketNo is not None:
            showIndent(outfile, level)
            outfile.write('ticketNo=%s,\n' % quote_python(self.ticketNo).encode(ExternalEncoding))
        if self.updatedDate is not None:
            showIndent(outfile, level)
            outfile.write('updatedDate=%s,\n' % quote_python(self.updatedDate).encode(ExternalEncoding))
        if self.webTicketResolution is not None:
            showIndent(outfile, level)
            outfile.write('webTicketResolution=%s,\n' % quote_python(self.webTicketResolution).encode(ExternalEncoding))
        if self.webTicketStatus is not None:
            showIndent(outfile, level)
            outfile.write('webTicketStatus=%s,\n' % quote_python(self.webTicketStatus).encode(ExternalEncoding))
        if self.webTicketType is not None:
            showIndent(outfile, level)
            outfile.write('webTicketType=%s,\n' % quote_python(self.webTicketType).encode(ExternalEncoding))
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'closedDate':
            closedDate_ = child_.text
            closedDate_ = self.gds_validate_string(closedDate_, node, 'closedDate')
            self.closedDate.append(closedDate_)
        elif nodeName_ == 'createdDate':
            createdDate_ = child_.text
            createdDate_ = self.gds_validate_string(createdDate_, node, 'createdDate')
            self.createdDate.append(createdDate_)
        elif nodeName_ == 'flagged':
            flagged_ = child_.text
            flagged_ = self.gds_validate_string(flagged_, node, 'flagged')
            self.flagged.append(flagged_)
        elif nodeName_ == 'messages':
            obj_ = messages.factory()
            obj_.build(child_)
            self.set_messages(obj_)
        elif nodeName_ == 'messageReferences':
            obj_ = messageReferences.factory()
            obj_.build(child_)
            self.set_messageReferences(obj_)
        elif nodeName_ == 'resolvedDate':
            resolvedDate_ = child_.text
            resolvedDate_ = self.gds_validate_string(resolvedDate_, node, 'resolvedDate')
            self.resolvedDate = resolvedDate_
        elif nodeName_ == 'ticketNo':
            ticketNo_ = child_.text
            ticketNo_ = self.gds_validate_string(ticketNo_, node, 'ticketNo')
            self.ticketNo = ticketNo_
        elif nodeName_ == 'updatedDate':
            updatedDate_ = child_.text
            updatedDate_ = self.gds_validate_string(updatedDate_, node, 'updatedDate')
            self.updatedDate = updatedDate_
        elif nodeName_ == 'webTicketResolution':
            webTicketResolution_ = child_.text
            webTicketResolution_ = self.gds_validate_string(webTicketResolution_, node, 'webTicketResolution')
            self.webTicketResolution = webTicketResolution_
        elif nodeName_ == 'webTicketStatus':
            webTicketStatus_ = child_.text
            webTicketStatus_ = self.gds_validate_string(webTicketStatus_, node, 'webTicketStatus')
            self.webTicketStatus = webTicketStatus_
        elif nodeName_ == 'webTicketType':
            webTicketType_ = child_.text
            webTicketType_ = self.gds_validate_string(webTicketType_, node, 'webTicketType')
            self.webTicketType = webTicketType_
        else:
            obj_ = self.gds_build_any(child_, 'ticket')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class ticket


class net(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, customerHandle=None, netBlocks=None, handle=None, netName=None, orgHandle=None, originASes=None, parentNetHandle=None, registrationDate=None, pocLinks=None, version=None, comment=None, anytypeobjs_=None):
        if customerHandle is None:
            self.customerHandle = []
        else:
            self.customerHandle = customerHandle
        if netBlocks is None:
            self.netBlocks = []
        else:
            self.netBlocks = netBlocks
        if handle is None:
            self.handle = []
        else:
            self.handle = handle
        if netName is None:
            self.netName = []
        else:
            self.netName = netName
        if orgHandle is None:
            self.orgHandle = []
        else:
            self.orgHandle = orgHandle
        if originASes is None:
            self.originASes = []
        else:
            self.originASes = originASes
        if parentNetHandle is None:
            self.parentNetHandle = []
        else:
            self.parentNetHandle = parentNetHandle
        if registrationDate is None:
            self.registrationDate = []
        else:
            self.registrationDate = registrationDate
        if pocLinks is None:
            self.pocLinks = []
        else:
            self.pocLinks = pocLinks
        if version is None:
            self.version = []
        else:
            self.version = version
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if net.subclass:
            return net.subclass(*args_, **kwargs_)
        else:
            return net(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_customerHandle(self): return self.customerHandle
    def set_customerHandle(self, customerHandle): self.customerHandle = customerHandle
    def add_customerHandle(self, value): self.customerHandle.append(value)
    def insert_customerHandle(self, index, value): self.customerHandle[index] = value
    def get_netBlocks(self): return self.netBlocks
    def set_netBlocks(self, netBlocks): self.netBlocks = netBlocks
    def add_netBlocks(self, value): self.netBlocks.append(value)
    def insert_netBlocks(self, index, value): self.netBlocks[index] = value
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def add_handle(self, value): self.handle.append(value)
    def insert_handle(self, index, value): self.handle[index] = value
    def get_netName(self): return self.netName
    def set_netName(self, netName): self.netName = netName
    def add_netName(self, value): self.netName.append(value)
    def insert_netName(self, index, value): self.netName[index] = value
    def get_orgHandle(self): return self.orgHandle
    def set_orgHandle(self, orgHandle): self.orgHandle = orgHandle
    def add_orgHandle(self, value): self.orgHandle.append(value)
    def insert_orgHandle(self, index, value): self.orgHandle[index] = value
    def get_originASes(self): return self.originASes
    def set_originASes(self, originASes): self.originASes = originASes
    def add_originASes(self, value): self.originASes.append(value)
    def insert_originASes(self, index, value): self.originASes[index] = value
    def get_parentNetHandle(self): return self.parentNetHandle
    def set_parentNetHandle(self, parentNetHandle): self.parentNetHandle = parentNetHandle
    def add_parentNetHandle(self, value): self.parentNetHandle.append(value)
    def insert_parentNetHandle(self, index, value): self.parentNetHandle[index] = value
    def get_registrationDate(self): return self.registrationDate
    def set_registrationDate(self, registrationDate): self.registrationDate = registrationDate
    def add_registrationDate(self, value): self.registrationDate.append(value)
    def insert_registrationDate(self, index, value): self.registrationDate[index] = value
    def get_pocLinks(self): return self.pocLinks
    def set_pocLinks(self, pocLinks): self.pocLinks = pocLinks
    def add_pocLinks(self, value): self.pocLinks.append(value)
    def insert_pocLinks(self, index, value): self.pocLinks[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def add_version(self, value): self.version.append(value)
    def insert_version(self, index, value): self.version[index] = value
    def validate_version(self, value):
        # Validate type version, a restriction on xs:token.
        pass
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def add_comment(self, value): self.comment.append(value)
    def insert_comment(self, index, value): self.comment[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.customerHandle or
            self.netBlocks or
            self.handle or
            self.netName or
            self.orgHandle or
            self.originASes or
            self.parentNetHandle or
            self.registrationDate or
            self.pocLinks or
            self.version or
            self.comment or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='net', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='net')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='net'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='net', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for customerHandle_ in self.customerHandle:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerHandle>%s</%scustomerHandle>%s' % (namespace_, self.gds_format_string(quote_xml(customerHandle_).encode(ExternalEncoding), input_name='customerHandle'), namespace_, eol_))
        for netBlocks_ in self.netBlocks:
            netBlocks_.export(outfile, level, namespace_, name_='netBlocks', pretty_print=pretty_print)
        for handle_ in self.handle:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shandle>%s</%shandle>%s' % (namespace_, self.gds_format_string(quote_xml(handle_).encode(ExternalEncoding), input_name='handle'), namespace_, eol_))
        for netName_ in self.netName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetName>%s</%snetName>%s' % (namespace_, self.gds_format_string(quote_xml(netName_).encode(ExternalEncoding), input_name='netName'), namespace_, eol_))
        for orgHandle_ in self.orgHandle:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorgHandle>%s</%sorgHandle>%s' % (namespace_, self.gds_format_string(quote_xml(orgHandle_).encode(ExternalEncoding), input_name='orgHandle'), namespace_, eol_))
        for originASes_ in self.originASes:
            originASes_.export(outfile, level, namespace_, name_='originASes', pretty_print=pretty_print)
        for parentNetHandle_ in self.parentNetHandle:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparentNetHandle>%s</%sparentNetHandle>%s' % (namespace_, self.gds_format_string(quote_xml(parentNetHandle_).encode(ExternalEncoding), input_name='parentNetHandle'), namespace_, eol_))
        for registrationDate_ in self.registrationDate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregistrationDate>%s</%sregistrationDate>%s' % (namespace_, self.gds_format_string(quote_xml(registrationDate_).encode(ExternalEncoding), input_name='registrationDate'), namespace_, eol_))
        for pocLinks_ in self.pocLinks:
            pocLinks_.export(outfile, level, namespace_, name_='pocLinks', pretty_print=pretty_print)
        for version_ in self.version:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_string(quote_xml(version_).encode(ExternalEncoding), input_name='version'), namespace_, eol_))
        for comment_ in self.comment:
            comment_.export(outfile, level, namespace_, name_='comment', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='net'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('customerHandle=[\n')
        level += 1
        for customerHandle_ in self.customerHandle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(customerHandle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('netBlocks=[\n')
        level += 1
        for netBlocks_ in self.netBlocks:
            showIndent(outfile, level)
            outfile.write('model_.netBlocks(\n')
            netBlocks_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('handle=[\n')
        level += 1
        for handle_ in self.handle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(handle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('netName=[\n')
        level += 1
        for netName_ in self.netName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(netName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('orgHandle=[\n')
        level += 1
        for orgHandle_ in self.orgHandle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(orgHandle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('originASes=[\n')
        level += 1
        for originASes_ in self.originASes:
            showIndent(outfile, level)
            outfile.write('model_.originASes(\n')
            originASes_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('parentNetHandle=[\n')
        level += 1
        for parentNetHandle_ in self.parentNetHandle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(parentNetHandle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('registrationDate=[\n')
        level += 1
        for registrationDate_ in self.registrationDate:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(registrationDate_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pocLinks=[\n')
        level += 1
        for pocLinks_ in self.pocLinks:
            showIndent(outfile, level)
            outfile.write('model_.pocLinks(\n')
            pocLinks_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('version=[\n')
        level += 1
        for version_ in self.version:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(version_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('comment=[\n')
        level += 1
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('model_.comment(\n')
            comment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'customerHandle':
            customerHandle_ = child_.text
            customerHandle_ = self.gds_validate_string(customerHandle_, node, 'customerHandle')
            self.customerHandle.append(customerHandle_)
        elif nodeName_ == 'netBlocks':
            obj_ = netBlocks.factory()
            obj_.build(child_)
            self.netBlocks.append(obj_)
        elif nodeName_ == 'handle':
            handle_ = child_.text
            handle_ = self.gds_validate_string(handle_, node, 'handle')
            self.handle.append(handle_)
        elif nodeName_ == 'netName':
            netName_ = child_.text
            netName_ = self.gds_validate_string(netName_, node, 'netName')
            self.netName.append(netName_)
        elif nodeName_ == 'orgHandle':
            orgHandle_ = child_.text
            orgHandle_ = self.gds_validate_string(orgHandle_, node, 'orgHandle')
            self.orgHandle.append(orgHandle_)
        elif nodeName_ == 'originASes':
            obj_ = originASes.factory()
            obj_.build(child_)
            self.originASes.append(obj_)
        elif nodeName_ == 'parentNetHandle':
            parentNetHandle_ = child_.text
            parentNetHandle_ = self.gds_validate_string(parentNetHandle_, node, 'parentNetHandle')
            self.parentNetHandle.append(parentNetHandle_)
        elif nodeName_ == 'registrationDate':
            registrationDate_ = child_.text
            registrationDate_ = self.gds_validate_string(registrationDate_, node, 'registrationDate')
            self.registrationDate.append(registrationDate_)
        elif nodeName_ == 'pocLinks':
            obj_ = pocLinks.factory()
            obj_.build(child_)
            self.pocLinks.append(obj_)
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = re_.sub(String_cleanup_pat_, " ", version_).strip()
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version.append(version_)
            self.validate_version(self.version)    # validate type version
        elif nodeName_ == 'comment':
            obj_ = comment.factory()
            obj_.build(child_)
            self.comment.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'net')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class net


class netBlock(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cidrLength=None, description=None, endAddress=None, startAddress=None, type_=None, anytypeobjs_=None):
        if cidrLength is None:
            self.cidrLength = []
        else:
            self.cidrLength = cidrLength
        if description is None:
            self.description = []
        else:
            self.description = description
        if endAddress is None:
            self.endAddress = []
        else:
            self.endAddress = endAddress
        if startAddress is None:
            self.startAddress = []
        else:
            self.startAddress = startAddress
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if netBlock.subclass:
            return netBlock.subclass(*args_, **kwargs_)
        else:
            return netBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cidrLength(self): return self.cidrLength
    def set_cidrLength(self, cidrLength): self.cidrLength = cidrLength
    def add_cidrLength(self, value): self.cidrLength.append(value)
    def insert_cidrLength(self, index, value): self.cidrLength[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_endAddress(self): return self.endAddress
    def set_endAddress(self, endAddress): self.endAddress = endAddress
    def add_endAddress(self, value): self.endAddress.append(value)
    def insert_endAddress(self, index, value): self.endAddress[index] = value
    def get_startAddress(self): return self.startAddress
    def set_startAddress(self, startAddress): self.startAddress = startAddress
    def add_startAddress(self, value): self.startAddress.append(value)
    def insert_startAddress(self, index, value): self.startAddress[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def validate_type(self, value):
        # Validate type type, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.cidrLength or
            self.description or
            self.endAddress or
            self.startAddress or
            self.type_ or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='netBlock', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='netBlock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='netBlock'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='netBlock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cidrLength_ in self.cidrLength:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scidrLength>%s</%scidrLength>%s' % (namespace_, self.gds_format_string(quote_xml(cidrLength_).encode(ExternalEncoding), input_name='cidrLength'), namespace_, eol_))
        for description_ in self.description:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(description_).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        for endAddress_ in self.endAddress:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendAddress>%s</%sendAddress>%s' % (namespace_, self.gds_format_string(quote_xml(endAddress_).encode(ExternalEncoding), input_name='endAddress'), namespace_, eol_))
        for startAddress_ in self.startAddress:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartAddress>%s</%sstartAddress>%s' % (namespace_, self.gds_format_string(quote_xml(startAddress_).encode(ExternalEncoding), input_name='startAddress'), namespace_, eol_))
        for type_ in self.type_:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_format_string(quote_xml(type_).encode(ExternalEncoding), input_name='type'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='netBlock'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cidrLength=[\n')
        level += 1
        for cidrLength_ in self.cidrLength:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(cidrLength_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(description_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('endAddress=[\n')
        level += 1
        for endAddress_ in self.endAddress:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(endAddress_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('startAddress=[\n')
        level += 1
        for startAddress_ in self.startAddress:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(startAddress_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cidrLength':
            cidrLength_ = child_.text
            cidrLength_ = self.gds_validate_string(cidrLength_, node, 'cidrLength')
            self.cidrLength.append(cidrLength_)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description.append(description_)
        elif nodeName_ == 'endAddress':
            endAddress_ = child_.text
            endAddress_ = self.gds_validate_string(endAddress_, node, 'endAddress')
            self.endAddress.append(endAddress_)
        elif nodeName_ == 'startAddress':
            startAddress_ = child_.text
            startAddress_ = self.gds_validate_string(startAddress_, node, 'startAddress')
            self.startAddress.append(startAddress_)
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_.append(type_)
            self.validate_type(self.type_)    # validate type type
        else:
            obj_ = self.gds_build_any(child_, 'netBlock')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class netBlock


class pocLinkRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, function=None, handle=None, description=None):
        self.function = _cast(None, function)
        self.handle = _cast(None, handle)
        self.description = _cast(None, description)
        pass
    def factory(*args_, **kwargs_):
        if pocLinkRef.subclass:
            return pocLinkRef.subclass(*args_, **kwargs_)
        else:
            return pocLinkRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='pocLinkRef', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pocLinkRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='pocLinkRef'):
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            outfile.write(' function=%s' % (self.gds_format_string(quote_attrib(self.function).encode(ExternalEncoding), input_name='function'), ))
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            outfile.write(' handle=%s' % (self.gds_format_string(quote_attrib(self.handle).encode(ExternalEncoding), input_name='handle'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='v:', name_='pocLinkRef', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='pocLinkRef'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            showIndent(outfile, level)
            outfile.write('function="%s",\n' % (self.function,))
        if self.handle is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            showIndent(outfile, level)
            outfile.write('handle="%s",\n' % (self.handle,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.add('function')
            self.function = value
        value = find_attr_value_('handle', node)
        if value is not None and 'handle' not in already_processed:
            already_processed.add('handle')
            self.handle = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pocLinkRef


class attachments(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachment=None):
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
    def factory(*args_, **kwargs_):
        if attachments.subclass:
            return attachments.subclass(*args_, **kwargs_)
        else:
            return attachments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def add_attachment(self, value): self.attachment.append(value)
    def insert_attachment(self, index, value): self.attachment[index] = value
    def hasContent_(self):
        if (
            self.attachment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachments', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachments')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachments'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachments', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespace_, name_='attachment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachments'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachment=[\n')
        level += 1
        for attachment_ in self.attachment:
            showIndent(outfile, level)
            outfile.write('model_.attachmentType9(\n')
            attachment_.exportLiteral(outfile, level, name_='attachmentType9')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachment':
            obj_ = attachmentType9.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
# end class attachments


class text(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, line=None):
        if line is None:
            self.line = []
        else:
            self.line = line
    def factory(*args_, **kwargs_):
        if text.subclass:
            return text.subclass(*args_, **kwargs_)
        else:
            return text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_line(self): return self.line
    def set_line(self, line): self.line = line
    def add_line(self, value): self.line.append(value)
    def insert_line(self, index, value): self.line[index] = value
    def hasContent_(self):
        if (
            self.line
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='text', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='text')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='text'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='text', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            line_.export(outfile, level, namespace_, name_='line', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='text'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('line=[\n')
        level += 1
        for line_ in self.line:
            showIndent(outfile, level)
            outfile.write('model_.line(\n')
            line_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'line':
            obj_ = line.factory()
            obj_.build(child_)
            self.line.append(obj_)
# end class text


class messages(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, message=None, attachment=None):
        if message is None:
            self.message = []
        else:
            self.message = message
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment
    def factory(*args_, **kwargs_):
        if messages.subclass:
            return messages.subclass(*args_, **kwargs_)
        else:
            return messages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def add_message(self, value): self.message.append(value)
    def insert_message(self, index, value): self.message[index] = value
    def get_attachment(self): return self.attachment
    def set_attachment(self, attachment): self.attachment = attachment
    def add_attachment(self, value): self.attachment.append(value)
    def insert_attachment(self, index, value): self.attachment[index] = value
    def hasContent_(self):
        if (
            self.message or
            self.attachment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='messages', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='messages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='messages'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='messages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for message_ in self.message:
            message_.export(outfile, level, namespace_, name_='message', pretty_print=pretty_print)
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespace_, name_='attachment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='messages'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('message=[\n')
        level += 1
        for message_ in self.message:
            showIndent(outfile, level)
            outfile.write('model_.message(\n')
            message_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachment=[\n')
        level += 1
        for attachment_ in self.attachment:
            showIndent(outfile, level)
            outfile.write('model_.attachmentType14(\n')
            attachment_.exportLiteral(outfile, level, name_='attachmentType14')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'message':
            obj_ = message.factory()
            obj_.build(child_)
            self.message.append(obj_)
        elif nodeName_ == 'attachment':
            obj_ = attachmentType14.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
# end class messages


class messageReferences(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, messageReference=None):
        if messageReference is None:
            self.messageReference = []
        else:
            self.messageReference = messageReference
    def factory(*args_, **kwargs_):
        if messageReferences.subclass:
            return messageReferences.subclass(*args_, **kwargs_)
        else:
            return messageReferences(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_messageReference(self): return self.messageReference
    def set_messageReference(self, messageReference): self.messageReference = messageReference
    def add_messageReference(self, value): self.messageReference.append(value)
    def insert_messageReference(self, index, value): self.messageReference[index] = value
    def hasContent_(self):
        if (
            self.messageReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='messageReferences', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='messageReferences')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='messageReferences'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='messageReferences', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for messageReference_ in self.messageReference:
            messageReference_.export(outfile, level, namespace_, name_='messageReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='messageReferences'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('messageReference=[\n')
        level += 1
        for messageReference_ in self.messageReference:
            showIndent(outfile, level)
            outfile.write('model_.messageReference(\n')
            messageReference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'messageReference':
            obj_ = messageReference.factory()
            obj_.build(child_)
            self.messageReference.append(obj_)
# end class messageReferences


class netBlocks(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, netBlock=None):
        if netBlock is None:
            self.netBlock = []
        else:
            self.netBlock = netBlock
    def factory(*args_, **kwargs_):
        if netBlocks.subclass:
            return netBlocks.subclass(*args_, **kwargs_)
        else:
            return netBlocks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_netBlock(self): return self.netBlock
    def set_netBlock(self, netBlock): self.netBlock = netBlock
    def add_netBlock(self, value): self.netBlock.append(value)
    def insert_netBlock(self, index, value): self.netBlock[index] = value
    def hasContent_(self):
        if (
            self.netBlock
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='netBlocks', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='netBlocks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='netBlocks'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='netBlocks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for netBlock_ in self.netBlock:
            netBlock_.export(outfile, level, namespace_, name_='netBlock', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='netBlocks'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('netBlock=[\n')
        level += 1
        for netBlock_ in self.netBlock:
            showIndent(outfile, level)
            outfile.write('model_.netBlock(\n')
            netBlock_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'netBlock':
            obj_ = netBlock.factory()
            obj_.build(child_)
            self.netBlock.append(obj_)
# end class netBlocks


class originASes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, originAS=None):
        if originAS is None:
            self.originAS = []
        else:
            self.originAS = originAS
    def factory(*args_, **kwargs_):
        if originASes.subclass:
            return originASes.subclass(*args_, **kwargs_)
        else:
            return originASes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originAS(self): return self.originAS
    def set_originAS(self, originAS): self.originAS = originAS
    def add_originAS(self, value): self.originAS.append(value)
    def insert_originAS(self, index, value): self.originAS[index] = value
    def hasContent_(self):
        if (
            self.originAS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='originASes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='originASes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='originASes'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='originASes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for originAS_ in self.originAS:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginAS>%s</%soriginAS>%s' % (namespace_, self.gds_format_string(quote_xml(originAS_).encode(ExternalEncoding), input_name='originAS'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='originASes'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('originAS=[\n')
        level += 1
        for originAS_ in self.originAS:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(originAS_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originAS':
            originAS_ = child_.text
            originAS_ = self.gds_validate_string(originAS_, node, 'originAS')
            self.originAS.append(originAS_)
# end class originASes


class pocLinks(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pocLinkRef=None):
        if pocLinkRef is None:
            self.pocLinkRef = []
        else:
            self.pocLinkRef = pocLinkRef
    def factory(*args_, **kwargs_):
        if pocLinks.subclass:
            return pocLinks.subclass(*args_, **kwargs_)
        else:
            return pocLinks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pocLinkRef(self): return self.pocLinkRef
    def set_pocLinkRef(self, pocLinkRef): self.pocLinkRef = pocLinkRef
    def add_pocLinkRef(self, value): self.pocLinkRef.append(value)
    def insert_pocLinkRef(self, index, value): self.pocLinkRef[index] = value
    def hasContent_(self):
        if (
            self.pocLinkRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='pocLinks', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pocLinks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='pocLinks'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='pocLinks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pocLinkRef_ in self.pocLinkRef:
            pocLinkRef_.export(outfile, level, namespace_, name_='pocLinkRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='pocLinks'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pocLinkRef=[\n')
        level += 1
        for pocLinkRef_ in self.pocLinkRef:
            showIndent(outfile, level)
            outfile.write('model_.pocLinkRef(\n')
            pocLinkRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pocLinkRef':
            obj_ = pocLinkRef.factory()
            obj_.build(child_)
            self.pocLinkRef.append(obj_)
# end class pocLinks


class version(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if version.subclass:
            return version.subclass(*args_, **kwargs_)
        else:
            return version(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='version', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='version')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='version'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='version', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='version'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class version


class comment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, line=None):
        if line is None:
            self.line = []
        else:
            self.line = line
    def factory(*args_, **kwargs_):
        if comment.subclass:
            return comment.subclass(*args_, **kwargs_)
        else:
            return comment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_line(self): return self.line
    def set_line(self, line): self.line = line
    def add_line(self, value): self.line.append(value)
    def insert_line(self, index, value): self.line[index] = value
    def hasContent_(self):
        if (
            self.line
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='comment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='comment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='comment'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='comment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            line_.export(outfile, level, namespace_, name_='line', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='comment'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('line=[\n')
        level += 1
        for line_ in self.line:
            showIndent(outfile, level)
            outfile.write('model_.line(\n')
            line_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'line':
            obj_ = line.factory()
            obj_.build(child_)
            self.line.append(obj_)
# end class comment


class type_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='type'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class type_


class line(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, valueOf_=None):
        self.number = _cast(int, number)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if line.subclass:
            return line.subclass(*args_, **kwargs_)
        else:
            return line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='line', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='line')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='line'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='v:', name_='line', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='line'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            try:
                self.number = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class line


class messageReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, messageId=None, attachmentReferences=None, anytypeobjs_=None):
        if messageId is None:
            self.messageId = []
        else:
            self.messageId = messageId
        if attachmentReferences is None:
            self.attachmentReferences = []
        else:
            self.attachmentReferences = attachmentReferences
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if messageReference.subclass:
            return messageReference.subclass(*args_, **kwargs_)
        else:
            return messageReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_messageId(self): return self.messageId
    def set_messageId(self, messageId): self.messageId = messageId
    def add_messageId(self, value): self.messageId.append(value)
    def insert_messageId(self, index, value): self.messageId[index] = value
    def get_attachmentReferences(self): return self.attachmentReferences
    def set_attachmentReferences(self, attachmentReferences): self.attachmentReferences = attachmentReferences
    def add_attachmentReferences(self, value): self.attachmentReferences.append(value)
    def insert_attachmentReferences(self, index, value): self.attachmentReferences[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.messageId or
            self.attachmentReferences or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='messageReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='messageReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='messageReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='messageReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for messageId_ in self.messageId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smessageId>%s</%smessageId>%s' % (namespace_, self.gds_format_integer(messageId_, input_name='messageId'), namespace_, eol_))
        for attachmentReferences_ in self.attachmentReferences:
            attachmentReferences_.export(outfile, level, namespace_, name_='attachmentReferences', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='messageReference'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('messageId=[\n')
        level += 1
        for messageId_ in self.messageId:
            showIndent(outfile, level)
            outfile.write('%d,\n' % messageId_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentReferences=[\n')
        level += 1
        for attachmentReferences_ in self.attachmentReferences:
            showIndent(outfile, level)
            outfile.write('model_.attachmentReferencesType18(\n')
            attachmentReferences_.exportLiteral(outfile, level, name_='attachmentReferencesType18')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'messageId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'messageId')
            self.messageId.append(ival_)
        elif nodeName_ == 'attachmentReferences':
            obj_ = attachmentReferencesType18.factory()
            obj_.build(child_)
            self.attachmentReferences.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'messageReference')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class messageReference


class attachmentId(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if attachmentId.subclass:
            return attachmentId.subclass(*args_, **kwargs_)
        else:
            return attachmentId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentId'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentId', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='attachmentId'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class attachmentId


class attachmentFilename(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if attachmentFilename.subclass:
            return attachmentFilename.subclass(*args_, **kwargs_)
        else:
            return attachmentFilename(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentFilename', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentFilename')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentFilename'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentFilename', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='attachmentFilename'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class attachmentFilename


class attachmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType.subclass:
            return attachmentType.subclass(*args_, **kwargs_)
        else:
            return attachmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType


class attachmentType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType2.subclass:
            return attachmentType2.subclass(*args_, **kwargs_)
        else:
            return attachmentType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType2')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType2


class attachmentReferencesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentReference=None):
        self.attachmentReference = attachmentReference
    def factory(*args_, **kwargs_):
        if attachmentReferencesType.subclass:
            return attachmentReferencesType.subclass(*args_, **kwargs_)
        else:
            return attachmentReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentReference(self): return self.attachmentReference
    def set_attachmentReference(self, attachmentReference): self.attachmentReference = attachmentReference
    def hasContent_(self):
        if (
            self.attachmentReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferencesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attachmentReference is not None:
            self.attachmentReference.export(outfile, level, namespace_, name_='attachmentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferencesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attachmentReference is not None:
            showIndent(outfile, level)
            outfile.write('attachmentReference=model_.attachmentReferenceType44(\n')
            self.attachmentReference.exportLiteral(outfile, level, name_='attachmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentReference':
            obj_ = attachmentReferenceType44.factory()
            obj_.build(child_)
            self.set_attachmentReference(obj_)
# end class attachmentReferencesType


class attachmentType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType5.subclass:
            return attachmentType5.subclass(*args_, **kwargs_)
        else:
            return attachmentType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType5')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType5


class attachmentType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType7.subclass:
            return attachmentType7.subclass(*args_, **kwargs_)
        else:
            return attachmentType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType7'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType7')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType7


class attachmentType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType9.subclass:
            return attachmentType9.subclass(*args_, **kwargs_)
        else:
            return attachmentType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType9', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType9'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType9')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType9


class attachmentReferencesType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentReference=None):
        if attachmentReference is None:
            self.attachmentReference = []
        else:
            self.attachmentReference = attachmentReference
    def factory(*args_, **kwargs_):
        if attachmentReferencesType11.subclass:
            return attachmentReferencesType11.subclass(*args_, **kwargs_)
        else:
            return attachmentReferencesType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentReference(self): return self.attachmentReference
    def set_attachmentReference(self, attachmentReference): self.attachmentReference = attachmentReference
    def add_attachmentReference(self, value): self.attachmentReference.append(value)
    def insert_attachmentReference(self, index, value): self.attachmentReference[index] = value
    def hasContent_(self):
        if (
            self.attachmentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferencesType11', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferencesType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferencesType11'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferencesType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentReference_ in self.attachmentReference:
            attachmentReference_.export(outfile, level, namespace_, name_='attachmentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferencesType11'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentReference=[\n')
        level += 1
        for attachmentReference_ in self.attachmentReference:
            showIndent(outfile, level)
            outfile.write('model_.attachmentReferenceType(\n')
            attachmentReference_.exportLiteral(outfile, level, name_='attachmentReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentReference':
            obj_ = attachmentReferenceType.factory()
            obj_.build(child_)
            self.attachmentReference.append(obj_)
# end class attachmentReferencesType11


class attachmentReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentId=None, attachmentFilename=None, anytypeobjs_=None):
        if attachmentId is None:
            self.attachmentId = []
        else:
            self.attachmentId = attachmentId
        if attachmentFilename is None:
            self.attachmentFilename = []
        else:
            self.attachmentFilename = attachmentFilename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentReferenceType.subclass:
            return attachmentReferenceType.subclass(*args_, **kwargs_)
        else:
            return attachmentReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentId(self): return self.attachmentId
    def set_attachmentId(self, attachmentId): self.attachmentId = attachmentId
    def add_attachmentId(self, value): self.attachmentId.append(value)
    def insert_attachmentId(self, index, value): self.attachmentId[index] = value
    def validate_attachmentId(self, value):
        # Validate type attachmentId, a restriction on xs:string.
        pass
    def get_attachmentFilename(self): return self.attachmentFilename
    def set_attachmentFilename(self, attachmentFilename): self.attachmentFilename = attachmentFilename
    def add_attachmentFilename(self, value): self.attachmentFilename.append(value)
    def insert_attachmentFilename(self, index, value): self.attachmentFilename[index] = value
    def validate_attachmentFilename(self, value):
        # Validate type attachmentFilename, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachmentId or
            self.attachmentFilename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentId>%s</%sattachmentId>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentId_).encode(ExternalEncoding), input_name='attachmentId'), namespace_, eol_))
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentFilename>%s</%sattachmentFilename>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentFilename_).encode(ExternalEncoding), input_name='attachmentFilename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentId=[\n')
        level += 1
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentFilename=[\n')
        level += 1
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentFilename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentId':
            attachmentId_ = child_.text
            attachmentId_ = self.gds_validate_string(attachmentId_, node, 'attachmentId')
            self.attachmentId.append(attachmentId_)
            self.validate_attachmentId(self.attachmentId)    # validate type attachmentId
        elif nodeName_ == 'attachmentFilename':
            attachmentFilename_ = child_.text
            attachmentFilename_ = self.gds_validate_string(attachmentFilename_, node, 'attachmentFilename')
            self.attachmentFilename.append(attachmentFilename_)
            self.validate_attachmentFilename(self.attachmentFilename)    # validate type attachmentFilename
        else:
            obj_ = self.gds_build_any(child_, 'attachmentReferenceType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentReferenceType


class attachmentType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType14.subclass:
            return attachmentType14.subclass(*args_, **kwargs_)
        else:
            return attachmentType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType14', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType14'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType14'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType14')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType14


class attachmentReferenceType16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentId=None, attachmentFilename=None, anytypeobjs_=None):
        if attachmentId is None:
            self.attachmentId = []
        else:
            self.attachmentId = attachmentId
        if attachmentFilename is None:
            self.attachmentFilename = []
        else:
            self.attachmentFilename = attachmentFilename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentReferenceType16.subclass:
            return attachmentReferenceType16.subclass(*args_, **kwargs_)
        else:
            return attachmentReferenceType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentId(self): return self.attachmentId
    def set_attachmentId(self, attachmentId): self.attachmentId = attachmentId
    def add_attachmentId(self, value): self.attachmentId.append(value)
    def insert_attachmentId(self, index, value): self.attachmentId[index] = value
    def validate_attachmentId(self, value):
        # Validate type attachmentId, a restriction on xs:string.
        pass
    def get_attachmentFilename(self): return self.attachmentFilename
    def set_attachmentFilename(self, attachmentFilename): self.attachmentFilename = attachmentFilename
    def add_attachmentFilename(self, value): self.attachmentFilename.append(value)
    def insert_attachmentFilename(self, index, value): self.attachmentFilename[index] = value
    def validate_attachmentFilename(self, value):
        # Validate type attachmentFilename, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachmentId or
            self.attachmentFilename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferenceType16', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferenceType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferenceType16'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferenceType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentId>%s</%sattachmentId>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentId_).encode(ExternalEncoding), input_name='attachmentId'), namespace_, eol_))
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentFilename>%s</%sattachmentFilename>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentFilename_).encode(ExternalEncoding), input_name='attachmentFilename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferenceType16'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentId=[\n')
        level += 1
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentFilename=[\n')
        level += 1
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentFilename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentId':
            attachmentId_ = child_.text
            attachmentId_ = self.gds_validate_string(attachmentId_, node, 'attachmentId')
            self.attachmentId.append(attachmentId_)
            self.validate_attachmentId(self.attachmentId)    # validate type attachmentId
        elif nodeName_ == 'attachmentFilename':
            attachmentFilename_ = child_.text
            attachmentFilename_ = self.gds_validate_string(attachmentFilename_, node, 'attachmentFilename')
            self.attachmentFilename.append(attachmentFilename_)
            self.validate_attachmentFilename(self.attachmentFilename)    # validate type attachmentFilename
        else:
            obj_ = self.gds_build_any(child_, 'attachmentReferenceType16')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentReferenceType16


class attachmentReferencesType18(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentReference=None):
        self.attachmentReference = attachmentReference
    def factory(*args_, **kwargs_):
        if attachmentReferencesType18.subclass:
            return attachmentReferencesType18.subclass(*args_, **kwargs_)
        else:
            return attachmentReferencesType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentReference(self): return self.attachmentReference
    def set_attachmentReference(self, attachmentReference): self.attachmentReference = attachmentReference
    def hasContent_(self):
        if (
            self.attachmentReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferencesType18', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferencesType18')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferencesType18'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferencesType18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attachmentReference is not None:
            self.attachmentReference.export(outfile, level, namespace_, name_='attachmentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferencesType18'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attachmentReference is not None:
            showIndent(outfile, level)
            outfile.write('attachmentReference=model_.attachmentReferenceType52(\n')
            self.attachmentReference.exportLiteral(outfile, level, name_='attachmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentReference':
            obj_ = attachmentReferenceType52.factory()
            obj_.build(child_)
            self.set_attachmentReference(obj_)
# end class attachmentReferencesType18


class attachmentReferencesType20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentReference=None):
        if attachmentReference is None:
            self.attachmentReference = []
        else:
            self.attachmentReference = attachmentReference
    def factory(*args_, **kwargs_):
        if attachmentReferencesType20.subclass:
            return attachmentReferencesType20.subclass(*args_, **kwargs_)
        else:
            return attachmentReferencesType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentReference(self): return self.attachmentReference
    def set_attachmentReference(self, attachmentReference): self.attachmentReference = attachmentReference
    def add_attachmentReference(self, value): self.attachmentReference.append(value)
    def insert_attachmentReference(self, index, value): self.attachmentReference[index] = value
    def hasContent_(self):
        if (
            self.attachmentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferencesType20', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferencesType20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferencesType20'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferencesType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentReference_ in self.attachmentReference:
            attachmentReference_.export(outfile, level, namespace_, name_='attachmentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferencesType20'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentReference=[\n')
        level += 1
        for attachmentReference_ in self.attachmentReference:
            showIndent(outfile, level)
            outfile.write('model_.attachmentReferenceType22(\n')
            attachmentReference_.exportLiteral(outfile, level, name_='attachmentReferenceType22')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentReference':
            obj_ = attachmentReferenceType22.factory()
            obj_.build(child_)
            self.attachmentReference.append(obj_)
# end class attachmentReferencesType20


class attachmentReferenceType22(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentId=None, attachmentFilename=None, anytypeobjs_=None):
        if attachmentId is None:
            self.attachmentId = []
        else:
            self.attachmentId = attachmentId
        if attachmentFilename is None:
            self.attachmentFilename = []
        else:
            self.attachmentFilename = attachmentFilename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentReferenceType22.subclass:
            return attachmentReferenceType22.subclass(*args_, **kwargs_)
        else:
            return attachmentReferenceType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentId(self): return self.attachmentId
    def set_attachmentId(self, attachmentId): self.attachmentId = attachmentId
    def add_attachmentId(self, value): self.attachmentId.append(value)
    def insert_attachmentId(self, index, value): self.attachmentId[index] = value
    def validate_attachmentId(self, value):
        # Validate type attachmentId, a restriction on xs:string.
        pass
    def get_attachmentFilename(self): return self.attachmentFilename
    def set_attachmentFilename(self, attachmentFilename): self.attachmentFilename = attachmentFilename
    def add_attachmentFilename(self, value): self.attachmentFilename.append(value)
    def insert_attachmentFilename(self, index, value): self.attachmentFilename[index] = value
    def validate_attachmentFilename(self, value):
        # Validate type attachmentFilename, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachmentId or
            self.attachmentFilename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferenceType22', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferenceType22')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferenceType22'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferenceType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentId>%s</%sattachmentId>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentId_).encode(ExternalEncoding), input_name='attachmentId'), namespace_, eol_))
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentFilename>%s</%sattachmentFilename>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentFilename_).encode(ExternalEncoding), input_name='attachmentFilename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferenceType22'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentId=[\n')
        level += 1
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentFilename=[\n')
        level += 1
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentFilename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentId':
            attachmentId_ = child_.text
            attachmentId_ = self.gds_validate_string(attachmentId_, node, 'attachmentId')
            self.attachmentId.append(attachmentId_)
            self.validate_attachmentId(self.attachmentId)    # validate type attachmentId
        elif nodeName_ == 'attachmentFilename':
            attachmentFilename_ = child_.text
            attachmentFilename_ = self.gds_validate_string(attachmentFilename_, node, 'attachmentFilename')
            self.attachmentFilename.append(attachmentFilename_)
            self.validate_attachmentFilename(self.attachmentFilename)    # validate type attachmentFilename
        else:
            obj_ = self.gds_build_any(child_, 'attachmentReferenceType22')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentReferenceType22


class attachmentReferenceType24(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentId=None, attachmentFilename=None, anytypeobjs_=None):
        if attachmentId is None:
            self.attachmentId = []
        else:
            self.attachmentId = attachmentId
        if attachmentFilename is None:
            self.attachmentFilename = []
        else:
            self.attachmentFilename = attachmentFilename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentReferenceType24.subclass:
            return attachmentReferenceType24.subclass(*args_, **kwargs_)
        else:
            return attachmentReferenceType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentId(self): return self.attachmentId
    def set_attachmentId(self, attachmentId): self.attachmentId = attachmentId
    def add_attachmentId(self, value): self.attachmentId.append(value)
    def insert_attachmentId(self, index, value): self.attachmentId[index] = value
    def validate_attachmentId(self, value):
        # Validate type attachmentId, a restriction on xs:string.
        pass
    def get_attachmentFilename(self): return self.attachmentFilename
    def set_attachmentFilename(self, attachmentFilename): self.attachmentFilename = attachmentFilename
    def add_attachmentFilename(self, value): self.attachmentFilename.append(value)
    def insert_attachmentFilename(self, index, value): self.attachmentFilename[index] = value
    def validate_attachmentFilename(self, value):
        # Validate type attachmentFilename, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachmentId or
            self.attachmentFilename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferenceType24', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferenceType24')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferenceType24'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferenceType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentId>%s</%sattachmentId>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentId_).encode(ExternalEncoding), input_name='attachmentId'), namespace_, eol_))
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentFilename>%s</%sattachmentFilename>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentFilename_).encode(ExternalEncoding), input_name='attachmentFilename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferenceType24'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentId=[\n')
        level += 1
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentFilename=[\n')
        level += 1
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentFilename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentId':
            attachmentId_ = child_.text
            attachmentId_ = self.gds_validate_string(attachmentId_, node, 'attachmentId')
            self.attachmentId.append(attachmentId_)
            self.validate_attachmentId(self.attachmentId)    # validate type attachmentId
        elif nodeName_ == 'attachmentFilename':
            attachmentFilename_ = child_.text
            attachmentFilename_ = self.gds_validate_string(attachmentFilename_, node, 'attachmentFilename')
            self.attachmentFilename.append(attachmentFilename_)
            self.validate_attachmentFilename(self.attachmentFilename)    # validate type attachmentFilename
        else:
            obj_ = self.gds_build_any(child_, 'attachmentReferenceType24')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentReferenceType24


class attachmentType26(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType26.subclass:
            return attachmentType26.subclass(*args_, **kwargs_)
        else:
            return attachmentType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType26', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType26')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType26'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType26'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType26')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType26


class attachmentType28(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType28.subclass:
            return attachmentType28.subclass(*args_, **kwargs_)
        else:
            return attachmentType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType28', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType28')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType28'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType28', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType28'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType28')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType28


class attachmentReferencesType30(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentReference=None):
        self.attachmentReference = attachmentReference
    def factory(*args_, **kwargs_):
        if attachmentReferencesType30.subclass:
            return attachmentReferencesType30.subclass(*args_, **kwargs_)
        else:
            return attachmentReferencesType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentReference(self): return self.attachmentReference
    def set_attachmentReference(self, attachmentReference): self.attachmentReference = attachmentReference
    def hasContent_(self):
        if (
            self.attachmentReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferencesType30', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferencesType30')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferencesType30'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferencesType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attachmentReference is not None:
            self.attachmentReference.export(outfile, level, namespace_, name_='attachmentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferencesType30'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attachmentReference is not None:
            showIndent(outfile, level)
            outfile.write('attachmentReference=model_.attachmentReferenceType44(\n')
            self.attachmentReference.exportLiteral(outfile, level, name_='attachmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentReference':
            obj_ = attachmentReferenceType44.factory()
            obj_.build(child_)
            self.set_attachmentReference(obj_)
# end class attachmentReferencesType30


class attachmentType32(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType32.subclass:
            return attachmentType32.subclass(*args_, **kwargs_)
        else:
            return attachmentType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType32', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType32'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType32'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType32')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType32


class attachmentType34(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType34.subclass:
            return attachmentType34.subclass(*args_, **kwargs_)
        else:
            return attachmentType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType34', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType34')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType34'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType34', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType34'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType34')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType34


class attachmentType36(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType36.subclass:
            return attachmentType36.subclass(*args_, **kwargs_)
        else:
            return attachmentType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType36', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType36')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType36'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType36', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType36'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType36')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType36


class attachmentReferencesType38(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentReference=None):
        if attachmentReference is None:
            self.attachmentReference = []
        else:
            self.attachmentReference = attachmentReference
    def factory(*args_, **kwargs_):
        if attachmentReferencesType38.subclass:
            return attachmentReferencesType38.subclass(*args_, **kwargs_)
        else:
            return attachmentReferencesType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentReference(self): return self.attachmentReference
    def set_attachmentReference(self, attachmentReference): self.attachmentReference = attachmentReference
    def add_attachmentReference(self, value): self.attachmentReference.append(value)
    def insert_attachmentReference(self, index, value): self.attachmentReference[index] = value
    def hasContent_(self):
        if (
            self.attachmentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferencesType38', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferencesType38')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferencesType38'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferencesType38', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentReference_ in self.attachmentReference:
            attachmentReference_.export(outfile, level, namespace_, name_='attachmentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferencesType38'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentReference=[\n')
        level += 1
        for attachmentReference_ in self.attachmentReference:
            showIndent(outfile, level)
            outfile.write('model_.attachmentReferenceType40(\n')
            attachmentReference_.exportLiteral(outfile, level, name_='attachmentReferenceType40')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentReference':
            obj_ = attachmentReferenceType40.factory()
            obj_.build(child_)
            self.attachmentReference.append(obj_)
# end class attachmentReferencesType38


class attachmentReferenceType40(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentId=None, attachmentFilename=None, anytypeobjs_=None):
        if attachmentId is None:
            self.attachmentId = []
        else:
            self.attachmentId = attachmentId
        if attachmentFilename is None:
            self.attachmentFilename = []
        else:
            self.attachmentFilename = attachmentFilename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentReferenceType40.subclass:
            return attachmentReferenceType40.subclass(*args_, **kwargs_)
        else:
            return attachmentReferenceType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentId(self): return self.attachmentId
    def set_attachmentId(self, attachmentId): self.attachmentId = attachmentId
    def add_attachmentId(self, value): self.attachmentId.append(value)
    def insert_attachmentId(self, index, value): self.attachmentId[index] = value
    def validate_attachmentId(self, value):
        # Validate type attachmentId, a restriction on xs:string.
        pass
    def get_attachmentFilename(self): return self.attachmentFilename
    def set_attachmentFilename(self, attachmentFilename): self.attachmentFilename = attachmentFilename
    def add_attachmentFilename(self, value): self.attachmentFilename.append(value)
    def insert_attachmentFilename(self, index, value): self.attachmentFilename[index] = value
    def validate_attachmentFilename(self, value):
        # Validate type attachmentFilename, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachmentId or
            self.attachmentFilename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferenceType40', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferenceType40')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferenceType40'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferenceType40', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentId>%s</%sattachmentId>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentId_).encode(ExternalEncoding), input_name='attachmentId'), namespace_, eol_))
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentFilename>%s</%sattachmentFilename>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentFilename_).encode(ExternalEncoding), input_name='attachmentFilename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferenceType40'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentId=[\n')
        level += 1
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentFilename=[\n')
        level += 1
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentFilename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentId':
            attachmentId_ = child_.text
            attachmentId_ = self.gds_validate_string(attachmentId_, node, 'attachmentId')
            self.attachmentId.append(attachmentId_)
            self.validate_attachmentId(self.attachmentId)    # validate type attachmentId
        elif nodeName_ == 'attachmentFilename':
            attachmentFilename_ = child_.text
            attachmentFilename_ = self.gds_validate_string(attachmentFilename_, node, 'attachmentFilename')
            self.attachmentFilename.append(attachmentFilename_)
            self.validate_attachmentFilename(self.attachmentFilename)    # validate type attachmentFilename
        else:
            obj_ = self.gds_build_any(child_, 'attachmentReferenceType40')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentReferenceType40


class attachmentType42(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None, filename=None, anytypeobjs_=None):
        if data is None:
            self.data = []
        else:
            self.data = data
        if filename is None:
            self.filename = []
        else:
            self.filename = filename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentType42.subclass:
            return attachmentType42.subclass(*args_, **kwargs_)
        else:
            return attachmentType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def add_filename(self, value): self.filename.append(value)
    def insert_filename(self, index, value): self.filename[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.data or
            self.filename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentType42', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentType42')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentType42'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentType42', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_ in self.data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespace_, self.gds_format_string(quote_xml(data_).encode(ExternalEncoding), input_name='data'), namespace_, eol_))
        for filename_ in self.filename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilename>%s</%sfilename>%s' % (namespace_, self.gds_format_string(quote_xml(filename_).encode(ExternalEncoding), input_name='filename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentType42'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filename=[\n')
        level += 1
        for filename_ in self.filename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(filename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data.append(data_)
        elif nodeName_ == 'filename':
            filename_ = child_.text
            filename_ = self.gds_validate_string(filename_, node, 'filename')
            self.filename.append(filename_)
        else:
            obj_ = self.gds_build_any(child_, 'attachmentType42')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentType42


class attachmentReferenceType44(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentId=None, attachmentFilename=None, anytypeobjs_=None):
        if attachmentId is None:
            self.attachmentId = []
        else:
            self.attachmentId = attachmentId
        if attachmentFilename is None:
            self.attachmentFilename = []
        else:
            self.attachmentFilename = attachmentFilename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentReferenceType44.subclass:
            return attachmentReferenceType44.subclass(*args_, **kwargs_)
        else:
            return attachmentReferenceType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentId(self): return self.attachmentId
    def set_attachmentId(self, attachmentId): self.attachmentId = attachmentId
    def add_attachmentId(self, value): self.attachmentId.append(value)
    def insert_attachmentId(self, index, value): self.attachmentId[index] = value
    def validate_attachmentId(self, value):
        # Validate type attachmentId, a restriction on xs:string.
        pass
    def get_attachmentFilename(self): return self.attachmentFilename
    def set_attachmentFilename(self, attachmentFilename): self.attachmentFilename = attachmentFilename
    def add_attachmentFilename(self, value): self.attachmentFilename.append(value)
    def insert_attachmentFilename(self, index, value): self.attachmentFilename[index] = value
    def validate_attachmentFilename(self, value):
        # Validate type attachmentFilename, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachmentId or
            self.attachmentFilename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferenceType44', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferenceType44')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferenceType44'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferenceType44', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentId>%s</%sattachmentId>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentId_).encode(ExternalEncoding), input_name='attachmentId'), namespace_, eol_))
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentFilename>%s</%sattachmentFilename>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentFilename_).encode(ExternalEncoding), input_name='attachmentFilename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferenceType44'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentId=[\n')
        level += 1
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentFilename=[\n')
        level += 1
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentFilename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentId':
            attachmentId_ = child_.text
            attachmentId_ = self.gds_validate_string(attachmentId_, node, 'attachmentId')
            self.attachmentId.append(attachmentId_)
            self.validate_attachmentId(self.attachmentId)    # validate type attachmentId
        elif nodeName_ == 'attachmentFilename':
            attachmentFilename_ = child_.text
            attachmentFilename_ = self.gds_validate_string(attachmentFilename_, node, 'attachmentFilename')
            self.attachmentFilename.append(attachmentFilename_)
            self.validate_attachmentFilename(self.attachmentFilename)    # validate type attachmentFilename
        else:
            obj_ = self.gds_build_any(child_, 'attachmentReferenceType44')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentReferenceType44


class attachmentReferencesType46(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentReference=None):
        self.attachmentReference = attachmentReference
    def factory(*args_, **kwargs_):
        if attachmentReferencesType46.subclass:
            return attachmentReferencesType46.subclass(*args_, **kwargs_)
        else:
            return attachmentReferencesType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentReference(self): return self.attachmentReference
    def set_attachmentReference(self, attachmentReference): self.attachmentReference = attachmentReference
    def hasContent_(self):
        if (
            self.attachmentReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferencesType46', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferencesType46')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferencesType46'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferencesType46', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attachmentReference is not None:
            self.attachmentReference.export(outfile, level, namespace_, name_='attachmentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferencesType46'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attachmentReference is not None:
            showIndent(outfile, level)
            outfile.write('attachmentReference=model_.attachmentReferenceType52(\n')
            self.attachmentReference.exportLiteral(outfile, level, name_='attachmentReference')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentReference':
            obj_ = attachmentReferenceType52.factory()
            obj_.build(child_)
            self.set_attachmentReference(obj_)
# end class attachmentReferencesType46


class attachmentReferencesType48(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentReference=None):
        if attachmentReference is None:
            self.attachmentReference = []
        else:
            self.attachmentReference = attachmentReference
    def factory(*args_, **kwargs_):
        if attachmentReferencesType48.subclass:
            return attachmentReferencesType48.subclass(*args_, **kwargs_)
        else:
            return attachmentReferencesType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentReference(self): return self.attachmentReference
    def set_attachmentReference(self, attachmentReference): self.attachmentReference = attachmentReference
    def add_attachmentReference(self, value): self.attachmentReference.append(value)
    def insert_attachmentReference(self, index, value): self.attachmentReference[index] = value
    def hasContent_(self):
        if (
            self.attachmentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferencesType48', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferencesType48')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferencesType48'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferencesType48', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentReference_ in self.attachmentReference:
            attachmentReference_.export(outfile, level, namespace_, name_='attachmentReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferencesType48'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentReference=[\n')
        level += 1
        for attachmentReference_ in self.attachmentReference:
            showIndent(outfile, level)
            outfile.write('model_.attachmentReferenceType50(\n')
            attachmentReference_.exportLiteral(outfile, level, name_='attachmentReferenceType50')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentReference':
            obj_ = attachmentReferenceType50.factory()
            obj_.build(child_)
            self.attachmentReference.append(obj_)
# end class attachmentReferencesType48


class attachmentReferenceType50(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentId=None, attachmentFilename=None, anytypeobjs_=None):
        if attachmentId is None:
            self.attachmentId = []
        else:
            self.attachmentId = attachmentId
        if attachmentFilename is None:
            self.attachmentFilename = []
        else:
            self.attachmentFilename = attachmentFilename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentReferenceType50.subclass:
            return attachmentReferenceType50.subclass(*args_, **kwargs_)
        else:
            return attachmentReferenceType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentId(self): return self.attachmentId
    def set_attachmentId(self, attachmentId): self.attachmentId = attachmentId
    def add_attachmentId(self, value): self.attachmentId.append(value)
    def insert_attachmentId(self, index, value): self.attachmentId[index] = value
    def validate_attachmentId(self, value):
        # Validate type attachmentId, a restriction on xs:string.
        pass
    def get_attachmentFilename(self): return self.attachmentFilename
    def set_attachmentFilename(self, attachmentFilename): self.attachmentFilename = attachmentFilename
    def add_attachmentFilename(self, value): self.attachmentFilename.append(value)
    def insert_attachmentFilename(self, index, value): self.attachmentFilename[index] = value
    def validate_attachmentFilename(self, value):
        # Validate type attachmentFilename, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachmentId or
            self.attachmentFilename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferenceType50', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferenceType50')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferenceType50'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferenceType50', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentId>%s</%sattachmentId>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentId_).encode(ExternalEncoding), input_name='attachmentId'), namespace_, eol_))
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentFilename>%s</%sattachmentFilename>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentFilename_).encode(ExternalEncoding), input_name='attachmentFilename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferenceType50'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentId=[\n')
        level += 1
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentFilename=[\n')
        level += 1
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentFilename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentId':
            attachmentId_ = child_.text
            attachmentId_ = self.gds_validate_string(attachmentId_, node, 'attachmentId')
            self.attachmentId.append(attachmentId_)
            self.validate_attachmentId(self.attachmentId)    # validate type attachmentId
        elif nodeName_ == 'attachmentFilename':
            attachmentFilename_ = child_.text
            attachmentFilename_ = self.gds_validate_string(attachmentFilename_, node, 'attachmentFilename')
            self.attachmentFilename.append(attachmentFilename_)
            self.validate_attachmentFilename(self.attachmentFilename)    # validate type attachmentFilename
        else:
            obj_ = self.gds_build_any(child_, 'attachmentReferenceType50')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentReferenceType50


class attachmentReferenceType52(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attachmentId=None, attachmentFilename=None, anytypeobjs_=None):
        if attachmentId is None:
            self.attachmentId = []
        else:
            self.attachmentId = attachmentId
        if attachmentFilename is None:
            self.attachmentFilename = []
        else:
            self.attachmentFilename = attachmentFilename
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if attachmentReferenceType52.subclass:
            return attachmentReferenceType52.subclass(*args_, **kwargs_)
        else:
            return attachmentReferenceType52(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attachmentId(self): return self.attachmentId
    def set_attachmentId(self, attachmentId): self.attachmentId = attachmentId
    def add_attachmentId(self, value): self.attachmentId.append(value)
    def insert_attachmentId(self, index, value): self.attachmentId[index] = value
    def validate_attachmentId(self, value):
        # Validate type attachmentId, a restriction on xs:string.
        pass
    def get_attachmentFilename(self): return self.attachmentFilename
    def set_attachmentFilename(self, attachmentFilename): self.attachmentFilename = attachmentFilename
    def add_attachmentFilename(self, value): self.attachmentFilename.append(value)
    def insert_attachmentFilename(self, index, value): self.attachmentFilename[index] = value
    def validate_attachmentFilename(self, value):
        # Validate type attachmentFilename, a restriction on xs:string.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.attachmentId or
            self.attachmentFilename or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='v:', name_='attachmentReferenceType52', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attachmentReferenceType52')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='v:', name_='attachmentReferenceType52'):
        pass
    def exportChildren(self, outfile, level, namespace_='v:', name_='attachmentReferenceType52', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentId>%s</%sattachmentId>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentId_).encode(ExternalEncoding), input_name='attachmentId'), namespace_, eol_))
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattachmentFilename>%s</%sattachmentFilename>%s' % (namespace_, self.gds_format_string(quote_xml(attachmentFilename_).encode(ExternalEncoding), input_name='attachmentFilename'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attachmentReferenceType52'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attachmentId=[\n')
        level += 1
        for attachmentId_ in self.attachmentId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentId_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attachmentFilename=[\n')
        level += 1
        for attachmentFilename_ in self.attachmentFilename:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(attachmentFilename_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attachmentId':
            attachmentId_ = child_.text
            attachmentId_ = self.gds_validate_string(attachmentId_, node, 'attachmentId')
            self.attachmentId.append(attachmentId_)
            self.validate_attachmentId(self.attachmentId)    # validate type attachmentId
        elif nodeName_ == 'attachmentFilename':
            attachmentFilename_ = child_.text
            attachmentFilename_ = self.gds_validate_string(attachmentFilename_, node, 'attachmentFilename')
            self.attachmentFilename.append(attachmentFilename_)
            self.validate_attachmentFilename(self.attachmentFilename)    # validate type attachmentFilename
        else:
            obj_ = self.gds_build_any(child_, 'attachmentReferenceType52')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class attachmentReferenceType52


GDSClassesMapping = {
    'attachmentReference': attachmentReferenceType50,
    'attachment': attachmentType42,
    'attachmentReferences': attachmentReferencesType46,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ticketedRequest'
        rootClass = ticketedRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(
        sys.stdout, 0, name_=rootTag,
        namespacedef_='xmlns="http://www.arin.net/regrws/core/v1"',
        pretty_print=True)
    return rootObj


def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ticketedRequest'
        rootClass = ticketedRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    content = etree_.tostring(
        rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = ticketedRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(
        sys.stdout, 0, name_="ticketedRequest",
        namespacedef_='xmlns="http://www.arin.net/regrws/core/v1"')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ticketedRequest'
        rootClass = ticketedRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from TicketedRequestPayload import *\n\n')
    sys.stdout.write('import TicketedRequestPayload as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "attachmentFilename",
    "attachmentId",
    "attachmentReferenceType",
    "attachmentReferenceType16",
    "attachmentReferenceType22",
    "attachmentReferenceType24",
    "attachmentReferenceType40",
    "attachmentReferenceType44",
    "attachmentReferenceType50",
    "attachmentReferenceType52",
    "attachmentReferencesType",
    "attachmentReferencesType11",
    "attachmentReferencesType18",
    "attachmentReferencesType20",
    "attachmentReferencesType30",
    "attachmentReferencesType38",
    "attachmentReferencesType46",
    "attachmentReferencesType48",
    "attachmentType",
    "attachmentType14",
    "attachmentType2",
    "attachmentType26",
    "attachmentType28",
    "attachmentType32",
    "attachmentType34",
    "attachmentType36",
    "attachmentType42",
    "attachmentType5",
    "attachmentType7",
    "attachmentType9",
    "attachments",
    "comment",
    "line",
    "message",
    "messageReference",
    "messageReferences",
    "messages",
    "net",
    "netBlock",
    "netBlocks",
    "originASes",
    "pocLinkRef",
    "pocLinks",
    "text",
    "ticket",
    "ticketedRequest",
    "type_",
    "version"
]
